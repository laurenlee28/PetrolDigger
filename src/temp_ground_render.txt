      // 6. Drawing Phase - 2D SIDE-VIEW CROSS SECTION
      groundCtx.clearRect(0, 0, groundWidth, groundHeight);
      groundCtx.imageSmoothingEnabled = false; // Pixel art style
      
      // Camera setup - drill stays in center, world scrolls
      const PIXEL_SCALE = 8; // Size of each pixel block
      const centerX = groundWidth / 2;
      const centerY = groundHeight / 2;
      const camOffsetX = -positionRef.current.x * PIXEL_SCALE;
      const camOffsetY = -positionRef.current.y * PIXEL_SCALE;
      
      // === DRAW GEOLOGICAL LAYERS (Background) ===
      groundCtx.save();
      groundCtx.translate(camOffsetX, camOffsetY);
      
      let layerY = 0;
      layers.forEach((layer, idx) => {
        const layerHeight = layer.thickness * PIXEL_SCALE;
        
        // Base layer color
        groundCtx.fillStyle = layer.color;
        groundCtx.fillRect(-groundWidth, layerY, groundWidth * 3, layerHeight);
        
        // Add pixel noise texture for variety
        for (let y = 0; y < layerHeight; y += PIXEL_SCALE) {
          for (let x = -groundWidth; x < groundWidth * 2; x += PIXEL_SCALE) {
            const noiseVal = Math.sin(x * 0.1 + y * 0.1) * Math.cos(x * 0.07);
            if (noiseVal > 0.3) {
              groundCtx.fillStyle = 'rgba(0, 0, 0, 0.1)';
              groundCtx.fillRect(x, layerY + y, PIXEL_SCALE, PIXEL_SCALE);
            } else if (noiseVal < -0.3) {
              groundCtx.fillStyle = 'rgba(255, 255, 255, 0.05)';
              groundCtx.fillRect(x, layerY + y, PIXEL_SCALE, PIXEL_SCALE);
            }
          }
        }
        
        // Layer boundary line
        if (idx > 0) {
          groundCtx.strokeStyle = 'rgba(0, 0, 0, 0.4)';
          groundCtx.lineWidth = 2;
          groundCtx.beginPath();
          groundCtx.moveTo(-groundWidth, layerY);
          groundCtx.lineTo(groundWidth * 2, layerY);
          groundCtx.stroke();
        }
        
        // Highlight target layer
        if (layer.target) {
          groundCtx.strokeStyle = 'rgba(16, 185, 129, 0.3)';
          groundCtx.lineWidth = 4;
          groundCtx.setLineDash([8, 4]);
          groundCtx.strokeRect(-groundWidth, layerY + 2, groundWidth * 3, layerHeight - 4);
          groundCtx.setLineDash([]);
        }
        
        layerY += layerHeight;
      });
      
      // === DRAW INTACT BLOCKS (Grid-based) ===
      blockGridRef.current.forEach((block) => {
        const blockX = block.x * PIXEL_SCALE;
        const blockY = block.y * PIXEL_SCALE;
        
        // Only draw blocks in view
        const screenX = blockX + camOffsetX;
        const screenY = blockY + camOffsetY;
        if (screenX > -PIXEL_SCALE * 2 && screenX < groundWidth + PIXEL_SCALE * 2 &&
            screenY > -PIXEL_SCALE * 2 && screenY < groundHeight + PIXEL_SCALE * 2) {
          
          // Block with health-based transparency
          groundCtx.fillStyle = block.color;
          groundCtx.globalAlpha = block.health;
          groundCtx.fillRect(blockX, blockY, PIXEL_SCALE, PIXEL_SCALE);
          
          // Cracked/damaged appearance for low health blocks
          if (block.health < 1 && block.health > 0) {
            groundCtx.globalAlpha = 1;
            groundCtx.strokeStyle = 'rgba(0, 0, 0, 0.5)';
            groundCtx.lineWidth = 1;
            
            // Draw cracks
            const crackDensity = Math.floor((1 - block.health) * 4);
            for (let i = 0; i < crackDensity; i++) {
              const x1 = blockX + (i * PIXEL_SCALE / 4);
              const y1 = blockY;
              const y2 = blockY + PIXEL_SCALE;
              groundCtx.beginPath();
              groundCtx.moveTo(x1, y1);
              groundCtx.lineTo(x1 + 2, y2);
              groundCtx.stroke();
            }
          }
          
          // Block outline for pixel art definition
          if (block.health > 0.3) {
            groundCtx.globalAlpha = 0.3;
            groundCtx.strokeStyle = '#000';
            groundCtx.lineWidth = 1;
            groundCtx.strokeRect(blockX, blockY, PIXEL_SCALE, PIXEL_SCALE);
          }
          
          groundCtx.globalAlpha = 1.0;
        }
      });
      
      // === DRAW DRILLED TUNNEL (Empty space where blocks are removed) ===
      // Show the path as a carved tunnel
      if (pathRef.current.length > 1) {
        groundCtx.fillStyle = 'rgba(0, 0, 0, 0.4)';
        groundCtx.strokeStyle = 'rgba(100, 100, 100, 0.3)';
        groundCtx.lineWidth = PIXEL_SCALE * 6;
        groundCtx.lineCap = 'round';
        groundCtx.lineJoin = 'round';
        
        groundCtx.beginPath();
        pathRef.current.forEach((point, i) => {
          const px = point.x * PIXEL_SCALE;
          const py = point.y * PIXEL_SCALE;
          if (i === 0) {
            groundCtx.moveTo(px, py);
          } else {
            groundCtx.lineTo(px, py);
          }
        });
        groundCtx.stroke();
      }
      
      // === DRAW PIXEL DEBRIS around drill ===
      if (active) {
        const drillX = positionRef.current.x * PIXEL_SCALE;
        const drillY = positionRef.current.y * PIXEL_SCALE;
        
        for (let i = 0; i < 12; i++) {
          const angle = (i / 12) * Math.PI * 2 + tick * 0.1;
          const dist = 15 + Math.sin(tick * 0.2 + i) * 5;
          const debrisX = drillX + Math.cos(angle) * dist;
          const debrisY = drillY + Math.sin(angle) * dist;
          
          let debrisColor = '#666';
          let checkY = 0;
          for (const layer of layers) {
            if (positionRef.current.y >= checkY && positionRef.current.y < checkY + layer.thickness) {
              debrisColor = layer.color;
              break;
            }
            checkY += layer.thickness;
          }
          
          groundCtx.fillStyle = debrisColor;
          groundCtx.globalAlpha = 0.6 + Math.sin(tick * 0.3 + i) * 0.2;
          groundCtx.fillRect(debrisX - 2, debrisY - 2, 4, 4);
        }
        groundCtx.globalAlpha = 1.0;
      }
      
      groundCtx.restore();
      
      // === DRAW DRILL POSITION MARKER (at center) ===
      groundCtx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
      groundCtx.lineWidth = 1;
      groundCtx.setLineDash([2, 2]);
      groundCtx.beginPath();
      groundCtx.moveTo(centerX - 15, centerY);
      groundCtx.lineTo(centerX + 15, centerY);
      groundCtx.moveTo(centerX, centerY - 15);
      groundCtx.lineTo(centerX, centerY + 15);
      groundCtx.stroke();
      groundCtx.setLineDash([]);
